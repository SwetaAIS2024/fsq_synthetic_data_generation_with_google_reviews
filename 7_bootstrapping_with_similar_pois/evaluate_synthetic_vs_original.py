# Evaluate Synthetic Check-ins vs. Original Check-ins
# This script compares the synthetic check-ins generated by bootstrapping with similar POIs
# to the original FSQ check-in dataset, using various statistical and distributional metrics.

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os

# File paths
orig_checkins_path = 'fsq_original_dataset/singapore_checkins.txt'
synth_checkins_path = '7_bootstrapping_with_similar_pois/synthetic_checkins_bootstrapped.csv'
poi_meta_path = 'fsq_original_dataset/sg_poi_id_name.txt'

# Load original check-ins (fix column order)
df_orig = pd.read_csv(orig_checkins_path, sep='\t', names=['user_id', 'poi_id', 'timestamp', 'misc'])

# Load synthetic check-ins
df_synth = pd.read_csv(synth_checkins_path)

# Load POI metadata
poi_meta = pd.read_csv(poi_meta_path, sep='\t', names=['poi_id', 'poi_name'])

# 1. Basic statistics
print('Original check-ins:', len(df_orig))
print('Synthetic check-ins:', len(df_synth))
print('Unique POIs (original):', df_orig['poi_id'].nunique())
print('Unique POIs (synthetic):', df_synth['poi_id'].nunique())
print('Unique users (original):', df_orig['user_id'].nunique())
print('Unique users (synthetic):', df_synth['user_id'].nunique())

# 2. Distribution: check-ins per POI
orig_poi_counts = df_orig['poi_id'].value_counts()
synth_poi_counts = df_synth['poi_id'].value_counts()

plt.figure(figsize=(10,5))
sns.histplot(orig_poi_counts, bins=50, color='blue', label='Original', stat='density', kde=True, alpha=0.5)
sns.histplot(synth_poi_counts, bins=50, color='orange', label='Synthetic', stat='density', kde=True, alpha=0.5)
plt.xlim(0, 500)
plt.legend()
plt.title('Distribution of Check-ins per POI')
plt.xlabel('Check-ins per POI')
plt.ylabel('Density')
plt.tight_layout()
plt.savefig('7_bootstrapping_with_similar_pois/checkins_per_poi_distribution.png')
plt.close()

# 3. Distribution: check-ins per user
orig_user_counts = df_orig['user_id'].value_counts()
synth_user_counts = df_synth['user_id'].value_counts()

plt.figure(figsize=(10,5))
# Limit x-axis to <2500 for check-ins per user
sns.histplot(orig_user_counts, bins=50, color='blue', label='Original', stat='density', kde=True, alpha=0.5)
sns.histplot(synth_user_counts, bins=50, color='orange', label='Synthetic', stat='density', kde=True, alpha=0.5)
plt.xlim(0, 1500)
plt.legend()
plt.title('Distribution of Check-ins per User')
plt.xlabel('Check-ins per User')
plt.ylabel('Density')
plt.tight_layout()
plt.savefig('7_bootstrapping_with_similar_pois/checkins_per_user_distribution.png')
plt.close()

# 4. Temporal distribution (if timestamps are present)
def parse_time(ts):
    try:
        return pd.to_datetime(ts)
    except:
        return pd.NaT

df_orig['parsed_time'] = df_orig['timestamp'].apply(parse_time)
df_synth['parsed_time'] = df_synth['timestamp'].apply(parse_time)

plt.figure(figsize=(12,5))
# Drop NaT before value_counts
orig_months = df_orig['parsed_time'].dropna().dt.to_period('M').value_counts().sort_index()
synth_months = df_synth['parsed_time'].dropna().dt.to_period('M').value_counts().sort_index()

# Debug info
print("Original: Parsed time NaT count:", df_orig['parsed_time'].isna().sum())
print("Synthetic: Parsed time NaT count:", df_synth['parsed_time'].isna().sum())
print("Original: Number of months:", len(orig_months))
print("Synthetic: Number of months:", len(synth_months))

# Limit number of months to plot if too many
max_months = 60
if len(orig_months) > max_months:
    orig_months = orig_months[-max_months:]
if len(synth_months) > max_months:
    synth_months = synth_months[-max_months:]

plt.plot(orig_months.index.astype(str), orig_months.values, label='Original', marker='o')
plt.plot(synth_months.index.astype(str), synth_months.values, label='Synthetic', marker='o')
plt.xticks(rotation=45)
plt.legend()
plt.title('Monthly Check-in Counts')
plt.xlabel('Month')
plt.ylabel('Check-ins')
plt.tight_layout()
plt.savefig('7_bootstrapping_with_similar_pois/monthly_checkin_counts.png')
plt.close()

# 5. Overlap analysis
common_pois = set(df_orig['poi_id']).intersection(set(df_synth['poi_id']))
print(f'POIs in both datasets: {len(common_pois)}')

# 6. Save summary stats
df_stats = pd.DataFrame({
    'dataset': ['original', 'synthetic'],
    'n_checkins': [len(df_orig), len(df_synth)],
    'n_unique_pois': [df_orig["poi_id"].nunique(), df_synth["poi_id"].nunique()],
    'n_unique_users': [df_orig["user_id"].nunique(), df_synth["user_id"].nunique()]
})
df_stats.to_csv('7_bootstrapping_with_similar_pois/synthetic_vs_original_stats.csv', index=False)

# Also save stats as a text file
with open('7_bootstrapping_with_similar_pois/synthetic_vs_original_stats.txt', 'w') as f:
    f.write('Synthetic vs Original Check-in Dataset Statistics\n')
    f.write('==============================================\n')
    for i, row in df_stats.iterrows():
        f.write(f"Dataset: {row['dataset']}\n")
        f.write(f"  Number of check-ins: {row['n_checkins']}\n")
        f.write(f"  Number of unique POIs: {row['n_unique_pois']}\n")
        f.write(f"  Number of unique users: {row['n_unique_users']}\n")
        f.write('\n')
    f.write(f"POIs in both datasets: {len(common_pois)}\n")
    f.write(f"Average check-ins per user (original): {orig_user_counts.mean()}\n")
    f.write(f"Average check-ins per user (synthetic): {synth_user_counts.mean()}\n")
    f.write(f"Max check-ins by a user (original): {orig_user_counts.max()}\n")
    f.write(f"Users with >1000 check-ins (original): {(orig_user_counts > 1000).sum()}\n")
    f.write(f"Users with >1000 check-ins (synthetic): {(synth_user_counts > 1000).sum()}\n")

# Additional statistics
print('Average check-ins per user (original):', orig_user_counts.mean())
print('Average check-ins per user (synthetic):', synth_user_counts.mean())
print('Max check-ins by a user (original):', orig_user_counts.max())
print('Users with >1000 check-ins (original):', (orig_user_counts > 1000).sum())
print('Users with >1000 check-ins (synthetic):', (synth_user_counts > 1000).sum())

print('Evaluation complete. Plots and summary saved in 7_bootstrapping_with_similar_pois/.')
